// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.15.0
// source: question.sql

package db

import (
	"context"
)

const createQuestion = `-- name: CreateQuestion :one
INSERT INTO
    "Question" (
        "QuestionGroupId",
        "Question"
    )
VALUES
    (
        $1 :: INT,
        $2 :: VARCHAR(2000)
    ) RETURNING "Id", "QuestionGroupId", "Question"
`

type CreateQuestionParams struct {
	QuestionGroupId int32
	Question        string
}

func (q *Queries) CreateQuestion(ctx context.Context, arg CreateQuestionParams) (Question, error) {
	row := q.db.QueryRowContext(ctx, createQuestion, arg.QuestionGroupId, arg.Question)
	var i Question
	err := row.Scan(&i.Id, &i.QuestionGroupId, &i.Question)
	return i, err
}

const getQuestionById = `-- name: GetQuestionById :one
SELECT
    "Id", "QuestionGroupId", "Question"
FROM
    "Question"
WHERE
    "Id" = $1 :: INT
LIMIT
    1
`

func (q *Queries) GetQuestionById(ctx context.Context, id int32) (Question, error) {
	row := q.db.QueryRowContext(ctx, getQuestionById, id)
	var i Question
	err := row.Scan(&i.Id, &i.QuestionGroupId, &i.Question)
	return i, err
}

const getQuestionByTestId = `-- name: GetQuestionByTestId :many
SELECT 
  q."Id", q."QuestionGroupId", q."Question"
FROM 
  "Test" t 
  INNER JOIN "QuestionGroup" qg ON t."Id" = qg."TestId" 
  INNER JOIN "Question" q ON q."QuestionGroupId" = qg."Id" 
WHERE 
  t."Id" = $1 :: INT ORDER BY q."Id" ASC
LIMIT
    $3 :: INT OFFSET $2 :: INT
`

type GetQuestionByTestIdParams struct {
	TestId int32
	Offset int32
	Limit  int32
}

func (q *Queries) GetQuestionByTestId(ctx context.Context, arg GetQuestionByTestIdParams) ([]Question, error) {
	rows, err := q.db.QueryContext(ctx, getQuestionByTestId, arg.TestId, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Question
	for rows.Next() {
		var i Question
		if err := rows.Scan(&i.Id, &i.QuestionGroupId, &i.Question); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getQuestionByTestIdRowCnt = `-- name: GetQuestionByTestIdRowCnt :one
SELECT 
  COUNT(q.*) 
FROM 
  "Test" t 
  INNER JOIN "QuestionGroup" qg ON t."Id" = qg."TestId" 
  INNER JOIN "Question" q ON q."QuestionGroupId" = qg."Id" 
WHERE 
  t."Id" = $1 :: INT ORDER BY q."Id" ASC
`

func (q *Queries) GetQuestionByTestIdRowCnt(ctx context.Context, testid int32) (int64, error) {
	row := q.db.QueryRowContext(ctx, getQuestionByTestIdRowCnt, testid)
	var count int64
	err := row.Scan(&count)
	return count, err
}
